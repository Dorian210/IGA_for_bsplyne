MODULE: IGA_for_bsplyne.ProblemIGA
==================================
Documentation for module IGA_for_bsplyne.ProblemIGA

CLASS: ProblemIGA
------------------
`ProblemIGA` class for linear elasticity on 3D multipatch B-spline volumes.

This class assembles the global stiffness matrix and right-hand side vector
from multiple :py:class:`IGAPatch` or :py:class:`IGAPatchDensity` objects,
applies Dirichlet boundary conditions, and solves the linear system to
compute the displacement field.

Attributes
----------
patches : list[IGAPatch]
    List of patch objects representing the B-spline patches of the problem.
connectivity : MultiPatchBSplineConnectivity
    Connectivity information linking the patches to global degrees of freedom.
dirichlet : Dirichlet
    Object defining the Dirichlet boundary conditions applied to the system.

Notes
-----
- The class handles multipatch assembly and global degrees of freedom mapping.
- Individual patch computations (stiffness, rhs, fields) are delegated to each patch.
- Post-processing quantities (strain, stress, von Mises) can be exported to ParaView
using :py:meth:`save_paraview`.
- Parallelization is used internally during assembly via `parallel_blocks`.

  >>> __init__(
    self,
    patches: list[IGA_for_bsplyne.IGAPatch.IGAPatch],
    connectivity: bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity,
    dirichlet: IGA_for_bsplyne.Dirichlet.Dirichlet
)
      Initialize a `ProblemIGA` instance.
      
      This constructor sets up a multipatch linear elasticity problem by
      storing the patches, the connectivity mapping between them, and the
      Dirichlet boundary conditions. The object itself does not assemble
      or solve the system until :py:meth:`lhs_rhs` or :py:meth:`solve` is called.
      
      Parameters
      ----------
      patches : list[IGAPatch]
          List of patch objects (instances of :py:class:`IGAPatch` or its subclasses)
          defining the geometry, material, and local operators.
      connectivity : MultiPatchBSplineConnectivity
          Connectivity object that maps local patch degrees of freedom
          to global degrees of freedom for assembly.
      dirichlet : Dirichlet
          Dirichlet boundary condition object defining the constrained degrees
          of freedom and their prescribed values.

  >>> lhs_rhs(
    self,
    verbose: bool = False,
    disable_parallel: bool = False
) -> tuple[scipy.sparse._matrix.spmatrix, numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]]
      Assemble the global linear system for the multipatch problem.
      
      This method computes the global left-hand side (LHS) matrix and
      right-hand side (RHS) vector for the linear elasticity problem
      represented by the set of patches in the :py:class:`ProblemIGA`.
      
      The RHS is assembled from the individual patch contributions
      using the connectivity mapping. The LHS (stiffness matrix) is
      assembled by computing each patch's local stiffness matrix
      and mapping its entries to the global system.
      
      Parameters
      ----------
      verbose : bool, optional
          If True, prints progress messages during assembly, by default False.
      disable_parallel : bool, optional
          If True, disables parallel execution for LHS assembly, by default False.
      
      Returns
      -------
      lhs : sps.spmatrix
          The assembled global sparse stiffness matrix of shape
          (3 * nb_unique_nodes, 3 * nb_unique_nodes).
      rhs : NDArray[np.floating]
          The assembled global right-hand side vector of shape
          (3 * nb_unique_nodes,).
      
      Notes
      -----
      - The factor 3 corresponds to the three physical displacement components
      (x, y, z) per node.
      - The patch contributions are gathered and summed according to the
      connectivity mapping defined in :py:attr:`connectivity`.
      - Parallelization is used by default for computing patch LHS and RHS blocks,
      and can be disabled via `disable_parallel`.

  >>> apply_dirichlet(
    self,
    lhs: scipy.sparse._matrix.spmatrix,
    rhs: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    verbose: bool = False
) -> tuple[scipy.sparse._matrix.spmatrix, numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]]
      Apply Dirichlet boundary conditions to the global linear system.
      
      This method modifies the global LHS matrix and RHS vector
      to enforce prescribed Dirichlet conditions. The Dirichlet object
      (:py:attr:`dirichlet`) provides the selection matrix `C` and
      prescribed values `k` such that:
      
          rhs = C.T @ (rhs - lhs @ k)
          lhs = C.T @ lhs @ C
      
      Parameters
      ----------
      lhs : sps.spmatrix
          Global sparse stiffness matrix of shape (3*nb_unique_nodes, 3*nb_unique_nodes).
      rhs : NDArray[np.floating]
          Global right-hand side vector of shape (3*nb_unique_nodes,).
      verbose : bool, optional
          If True, prints progress messages during application of Dirichlet
          conditions, by default False.
      
      Returns
      -------
      lhs : sps.spmatrix
          Reduced stiffness matrix with Dirichlet conditions applied.
      rhs : NDArray[np.floating]
          Reduced RHS vector corresponding to the free degrees of freedom.
      
      Notes
      -----
      - The operation effectively reduces the system to the unconstrained
      degrees of freedom.
      - Use :py:meth:`solve_from_lhs_rhs` after applying Dirichlet conditions
      to obtain the solution.

  >>> solve_from_lhs_rhs(
    self,
    lhs: scipy.sparse._matrix.spmatrix,
    rhs: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    iterative_solve: bool = False,
    verbose: bool = True
) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
      Solve a linear system for the given left-hand side matrix and right-hand side vector.
      
      This method solves the linear system
      `lhs @ dof = rhs` for the unknown degrees of freedom.
      It does not apply Dirichlet boundary conditions: the inputs should
      already be modified accordingly (e.g., via :py:meth:`apply_dirichlet`).
      
      Parameters
      ----------
      lhs : sps.spmatrix
          Sparse matrix representing the system after applying Dirichlet conditions.
          Can have arbitrary shape as long as it matches `rhs`.
      rhs : NDArray[np.floating]
          Right-hand side vector, already accounting for Dirichlet conditions.
      iterative_solve : bool, optional
          If True, use an iterative solver (conjugate gradient with diagonal preconditioner),
          otherwise use a direct solver (Cholesky factorization).
          Specs for 1_534_278 dof :
              - CG preconditioned with diagonal (`scipy.sparse.diags(1/lhs.diagonal())`):
                  solved to 1e-5 tol in 131 min
              - CG preconditioned with AMG (`pyamg.smoothed_aggregation_solver(lhs).aspreconditioner()`):
                  solved to 1e-5 tol in 225 min
              - Cholesky: solved in 32 min
          By default False.
      verbose : bool, optional
          If True, print progress messages during the solving process. Default is True.
      
      Returns
      -------
      dof : NDArray[np.floating]
          Solution vector representing the degrees of freedom in the
          unconstrained/reduced system.
      
      Notes
      -----
      - The iterative solver prints residuals at each iteration if `verbose=True`.
      - For large systems, iterative solvers can be more memory efficient, but may require
      tuning the preconditioner.
      - Use :py:meth:`apply_dirichlet` to handle Dirichlet constraints before calling this method.

  >>> solve(
    self,
    iterative_solve=False
) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
      Solve the linear elasticity problem for the multipatch IGA system.
      
      This method assembles the global system, applies Dirichlet boundary conditions,
      and solves for the displacements. The solution returned includes all degrees
      of freedom in packed notation, with Dirichlet values restored.
      
      Parameters
      ----------
      iterative_solve : bool, optional
          If True, solve the system using an iterative solver (preconditioned
          conjugate gradient), otherwise use a direct solver (Cholesky). Default is False.
          Exemple notes on performance for large systems (~1.5 million DOFs):
              - CG with diagonal preconditioner: 1e-5 tol in ~131 min
              - CG with AMG preconditioner: 1e-5 tol in ~225 min
              - Cholesky factorization: ~32 min
      
      Returns
      -------
      u : NDArray[np.floating]
          Displacement vector including all degrees of freedom, in packed notation.
          Shape: (3, nb_unique_nodes), with the first dimension corresponding
          to the physical coordinates (x, y, z).
      
      See Also
      --------
      lhs_rhs : assemble the global system.
      apply_dirichlet : apply Dirichlet boundary conditions.
      solve_from_lhs_rhs : solve a reduced linear system.

  >>> save_paraview(
    self,
    u: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    path: str,
    name: str,
    n_eval_per_elem: int = 10,
    disable_parallel: bool = False
)
      Export displacements and derived fields to Paraview files for visualization.
      
      This method separates the global displacement vector into patch-local fields,
      evaluates additional post-processing fields (strain, stress, von Mises, etc.)
      at a regular grid of points per element, and saves all data in a format readable
      by Paraview. The evaluation is done in parallel using `parallel_blocks` unless
      `disable_parallel` is True.
      
      Parameters
      ----------
      u : NDArray[np.floating]
          Displacement field in packed notation, including Dirichlet values.
          Shape: (3, nb_unique_nodes), where the first dimension corresponds to
          physical coordinates (x, y, z).
      path : str
          Directory path where the Paraview files will be saved.
      name : str
          Base name for the Paraview files.
      n_eval_per_elem : int, optional
          Number of evaluation points per element in each parametric direction.
          Default is 10.
      disable_parallel : bool, optional
          If True, disables parallel evaluation of patch fields. Default is False.
      
      Notes
      -----
      - For each patch, the method evaluates fields at `n_eval_per_elem` points along
      each parametric direction and computes derived quantities via
      `IGAPatch.make_paraview_fields`.
      - The output can include displacement, strain, stress, von Mises stress, and
      density if applicable (e.g., in `IGAPatchDensity`).
      - The `connectivity` object handles assembling the patches into a global
      representation for Paraview.
      
      See Also
      --------
      IGAPatch.make_paraview_fields : compute local fields for each patch.
      MultiPatchBSplineConnectivity.save_paraview : handles saving the assembled global data.

