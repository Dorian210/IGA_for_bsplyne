MODULE: IGA_for_bsplyne.Dirichlet
=================================
Documentation for module IGA_for_bsplyne.Dirichlet

CLASS: Dirichlet
-----------------
Affine representation of linear Dirichlet constraints.

This class represents Dirichlet boundary conditions through an affine
transformation between a reduced vector of free parameters (`dof`)
and the full physical displacement vector (`u`):

    u = C @ dof + k

where:

- `u` is the full displacement vector satisfying all imposed constraints.
- `dof` is the reduced vector of unconstrained degrees of freedom.
- `C` is a sparse matrix whose columns form a basis of admissible variations.
- `k` is a particular displacement vector satisfying the constraints.

This representation allows:
- elimination of constrained DOFs,
- support for general linear multi-point constraints.

Attributes
----------
C : sps.csc_matrix of shape (n_full_dofs, n_free_dofs)
    Sparse matrix defining the linear mapping from reduced DOFs to full DOFs.
k : NDArray of float of shape (n_full_dofs,)
    Particular solution ensuring that `u` satisfies the Dirichlet constraints.

  >>> __init__(
    self,
    C: scipy.sparse._matrix.spmatrix,
    k: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
)
      Initialize an affine Dirichlet constraint representation.
      
      Parameters
      ----------
      C : sps.spmatrix
          Sparse matrix of shape (n_full_dofs, n_free_dofs) defining
          the linear mapping from reduced DOFs to full DOFs.
      k : NDArray[np.floating]
          Vector of shape (n_full_dofs,) defining the affine offset.
      
      Notes
      -----
      The matrix `C` is internally converted to CSC format for efficient
      matrix-vector products.

  >>> eye(cls, size: int)
      Create an unconstrained Dirichlet mapping.
      
      This method returns a `Dirichlet` object corresponding to the identity
      transformation:
      
          u = dof
      
      i.e. no Dirichlet constraints are applied.
      
      Parameters
      ----------
      size : int
          Number of degrees of freedom.
      
      Returns
      -------
      dirichlet : Dirichlet
          Identity `Dirichlet` object with:
          - C = identity(size)
          - k = 0

  >>> lock_disp_inds(
    cls,
    inds: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    k: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
)
      Create Dirichlet constraints by prescribing displacement values at selected DOFs.
      
      This method enforces pointwise Dirichlet conditions of the form:
      
          u[i] = k[i]    for i in inds
      
      All other DOFs remain unconstrained.
      
      Parameters
      ----------
      inds : NDArray[np.integer]
          Indices of the displacement vector `u` to be constrained.
      k : NDArray[np.floating]
          Target displacement vector of shape (n_full_dofs,). Only the
          values at `inds` are enforced.
      
      Returns
      -------
      dirichlet : Dirichlet
          `Dirichlet` instance representing the prescribed displacement constraints.
      
      Notes
      -----
      Constrained DOFs are removed from the reduced DOF vector. The resulting
      number of reduced DOFs will therefore be smaller than `k.size`.

  >>> set_u_inds_vals(
    self,
    inds: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    vals: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
)
      Impose pointwise Dirichlet conditions by prescribing displacement values
      at selected full DOFs.
      
      This method enforces constraints of the form:
      
          u[i] = vals[j]     for i = inds[j]
      
      by modifying the affine mapping:
      
          u = C @ dof + k
      
      The modification removes the corresponding admissible variations in `C`
      and updates `k` so that the prescribed values are always satisfied.
      As a result, constrained DOFs are eliminated from the reduced DOF vector.
      
      Parameters
      ----------
      inds : NDArray[np.integer]
          Indices of the full displacement vector `u` to constrain.
      vals : NDArray[np.floating]
          Prescribed displacement values associated with `inds`.
          Must have the same length as `inds`.
      
      Notes
      -----
      - Rows of `C` corresponding to constrained DOFs are zeroed.
      - Columns of `C` that become unused are removed, which may reduce
        the number of reduced DOFs.
      - The affine offset `k` is updated to enforce the prescribed values.
      - This operation modifies the current Dirichlet object in place.

  >>> slave_reference_linear_relation(
    self,
    slaves: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    references: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    coefs: Optional[numpy.ndarray[Any, numpy.dtype[numpy.floating]]] = None
)
      Impose linear multi-point constraints between full DOFs.
      
      This method enforces relations of the form:
      
          u[slave_i] = sum_j coefs[i, j] * u[references[i, j]]
      
      by modifying the affine mapping:
      
          u = C @ dof + k
      
      Slave DOFs are expressed as linear combinations of reference DOFs.
      The corresponding admissible variations are propagated into `C`
      and `k`, effectively eliminating slave DOFs from the reduced parameter
      vector while preserving the imposed constraints.
      
      Parameters
      ----------
      slaves : NDArray[np.integer] of shape (n_slaves,)
          Indices of DOFs that are constrained (slave DOFs).
      references : NDArray[np.integer] of shape (n_slaves, n_refs)
          Reference DOF indices controlling each slave DOF.
          Row `i` contains the references associated with `slaves[i]`.
      coefs : NDArray[np.floating], optional, shape (n_slaves, n_refs)
          Linear combination coefficients linking references to slaves.
          If None, slaves are defined as the average of their references.
      
      Notes
      -----
      - Slave DOFs are removed from the reduced DOF vector.
      - The constraint propagation accounts for hierarchical dependencies
        between slave DOFs using a topological ordering.
      - This operation is typically faster than using `DirichletConstraintHandler`,
        as it directly modifies the affine mapping without constructing
        intermediate constraint objects.
      - Cyclic dependencies between slaves are not supported and will raise an error.
      - This operation modifies the current Dirichlet object in place.
      
      Examples
      --------
      To impose u[i] = 0.5 * (u[j] + u[k]):
      
      >>> slaves = np.array([i])
      >>> references = np.array([[j, k]])
      >>> coefs = np.array([[0.5, 0.5]])
      >>> dirichlet.slave_reference_linear_relation(slaves, references, coefs)

  >>> u_du_ddof(
    self,
    dof: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
) -> tuple[numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]], scipy.sparse._csc.csc_matrix]
      Evaluate the displacement field and its derivative with respect to the reduced DOFs.
      
      The displacement field is obtained from the affine mapping:
      
          u = C @ dof + k
      
      Since the mapping is affine, the derivative of `u` with respect to `dof`
      is constant and equal to `C`.
      
      Parameters
      ----------
      dof : NDArray[np.floating] of shape (n_dof,)
          Reduced degrees of freedom.
      
      Returns
      -------
      u : NDArray[np.floating] of shape (n_u,)
          Displacement field.
      du_ddof : sps.csc_matrix of shape (n_u, n_dof)
          Jacobian of `u` with respect to `dof` : the matrix `C`.
      
      Notes
      -----
      The returned derivative is independent of `dof` because the mapping is affine.

  >>> u(
    self,
    dof: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
      Evaluate the displacement field from reduced DOFs.
      
      The displacement field is computed using the affine mapping:
      
          u = C @ dof + k
      
      Parameters
      ----------
      dof : NDArray[np.floating]
          Reduced degrees of freedom. Can be either:
      
          - shape (n_dof,)
          - shape (..., n_dof) for batched evaluation
      
      Returns
      -------
      u : NDArray[np.floating]
          Displacement field with shape:
      
          - (n_u,) if `dof` is 1D
          - (..., n_u) if `dof` is batched
      
      Notes
      -----
      This method supports vectorized evaluation over multiple DOF vectors.

  >>> dof_lsq(
    self,
    u: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
      Compute reduced DOFs from a displacement field using a least-squares projection.
      
      This method computes `dof` such that:
      
          u ≈ C @ dof + k
      
      by solving the normal equations:
      
          (Cᵀ C) dof = Cᵀ (u - k)
      
      Parameters
      ----------
      u : NDArray[np.floating]
          Displacement field. Can be either:
      
          - shape (n_u,)
          - shape (..., n_u) for batched projection
      
      Returns
      -------
      dof : NDArray[np.floating]
          Reduced degrees of freedom with shape:
      
          - (n_dof,) if `u` is 1D
          - (..., n_dof) if `u` is batched
      
      Notes
      -----
      This operation performs a least-squares inversion of the affine mapping.
      If `C` does not have full column rank, the solution corresponds to a
      minimum-norm least-squares solution.
      
      The system `(Cᵀ C)` is solved using a sparse linear solver.


CLASS: DirichletConstraintHandler
----------------------------------
Accumulate affine linear constraints and construct the associated Dirichlet mapping.

This class is designed to impose linear affine constraints of the form:

    D @ u = c

where `u` is the full displacement (or state) vector. Constraints are progressively
accumulated and, once fully specified, converted into an affine parametrization of
the admissible solution space:

    u = C @ dof + k

where:

- `C` is a basis of the nullspace of `D` (i.e. `D @ C = 0`) obtained by
QR decomposition,
- `k` is a particular solution satisfying the constraints,
obtained through the QR decomposition which helps solve:

    D k = c

- `dof` is a reduced vector of unconstrained degrees of freedom.

The main purpose of this class is to provide a flexible and robust interface
to define constraints before constructing a `Dirichlet` object representing
the reduced parametrization.

Typical workflow
----------------
1. Create a handler with the number of physical DOFs (`u`).
2. Add constraint equations using helper methods.
3. **Ensure that all reference DOFs (e.g., translations or rotations introduced for
rigid-body relations) are fully constrained before computing `C` and `k`.**
4. Build the reduced representation `(C, k)` or directly create a `Dirichlet` object.

This separation allows constraints to be assembled incrementally and validated
before generating the final affine mapping.

Attributes
----------
nb_dofs_init : int
    Number of DOFs in the original unconstrained system (physical DOFs `u`).
lhs : sps.spmatrix
    Accumulated constraint matrix `D`.
rhs : NDArray[np.floating]
    Accumulated right-hand side vector `c`.

Notes
-----
- The constraint system may include additional reference DOFs introduced
to express kinematic relations or rigid-body behaviors.
- **All reference DOFs must be fully constrained before computing `C` and `k`;**
otherwise, DOFs that lie in the kernel of `D` cannot be controlled and imposed values
(e.g., prescribed translations) may not appear in the resulting solution `k`.
- The resulting affine mapping guarantees that any generated vector `u`
satisfies all imposed constraints.

  >>> __init__(self, nb_dofs_init: int)
      Initialize a Dirichlet constraint handler.
      
      Parameters
      ----------
      nb_dofs_init : int
          The number of initial degrees of freedom in the unconstrained system.
          This value is used to size the initial constraint matrix and manage
          later extensions with reference DOFs.

  >>> copy(self) -> IGA_for_bsplyne.Dirichlet.DirichletConstraintHandler
      Create a deep copy of this DirichletConstraintHandler instance.
      
      Returns
      -------
      DirichletConstraintHandler
          A new instance with the same initial number of DOFs, constraint matrix, and right-hand side vector.
          All internal data is copied, so modifications to the returned handler do not affect the original.

  >>> add_eqs(
    self,
    lhs: scipy.sparse._matrix.spmatrix,
    rhs: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
)
      Append linear affine constraint equations to the global constraint system.
      
      Adds equations of the form:
      
          lhs @ u = rhs
      
      to the accumulated constraint system `D @ u = c`.
      
      If `lhs` is expressed only in terms of the initial physical DOFs
      (`nb_dofs_init` columns), it is automatically extended with zero-padding
      to match the current number of DOFs (e.g. after reference DOFs have been added).
      
      Parameters
      ----------
      lhs : sps.spmatrix of shape (n_eqs, n_dofs)
          Constraint matrix defining the left-hand side of the equations.
          The number of columns must match either:
          - the initial number of DOFs (`nb_dofs_init`), or
          - the current number of DOFs in the handler.
      
      rhs : NDArray[np.floating] of shape (n_eqs,)
          Right-hand side values associated with the constraint equations.
      
      Raises
      ------
      ValueError
          If the number of columns of `lhs` is incompatible with the current
          constraint system.
      
      Notes
      -----
      Constraints are appended to the existing system and are not simplified
      or checked for redundancy.

  >>> add_ref_dofs(self, nb_dofs: int)
      Append additional reference DOFs to the constraint system.
      
      This method increases the size of the global DOF vector by adding
      `nb_dofs` new reference DOFs. These DOFs are introduced without
      imposing any constraint, i.e. they appear with zero coefficients
      in all existing equations.
      
      Parameters
      ----------
      nb_dofs : int
          Number of reference DOFs to append to the global DOF vector.
      
      Notes
      -----
      Reference DOFs are typically used to express kinematic relations,
      rigid body motions, or other auxiliary constraint parametrizations.

  >>> add_ref_dofs_with_behavior(
    self,
    behavior_mat: scipy.sparse._matrix.spmatrix,
    slave_inds: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]]
)
      Introduce reference DOFs and constrain slave DOFs through a linear relation.
      
      This method appends new reference DOFs and enforces a linear behavioral
      relation linking these reference DOFs to existing DOFs (called *slave DOFs*).
      The imposed constraints take the form:
      
          behavior_mat @ ref_dofs - u[slave_inds] = 0
      
      
      Parameters
      ----------
      behavior_mat : sps.spmatrix of shape (n_slaves, n_ref_dofs)
          Linear operator defining how each reference DOF contributes to the
          corresponding slave DOFs.
      
      slave_inds : NDArray[np.integer] of shape (n_slaves,)
          Indices of slave DOFs that are controlled by the reference DOFs.
          The ordering must match the rows of `behavior_mat`.
      
      Raises
      ------
      AssertionError
          If the number of slave DOFs is inconsistent with the number of
          rows of `behavior_mat`.
      
      Notes
      -----
      This method first adds the reference DOFs to the global system and then
      appends the corresponding constraint equations.

  >>> add_rigid_body_constraint(
    self,
    ref_point: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    slaves_inds: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    slaves_positions: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
)
      Constrain slave nodes to follow a rigid body motion defined by a reference point.
      
      This method introduces six reference DOFs representing a rigid body motion:
      three rotations and three translations (in this order) around a reference point.
      The displacement of each slave node is constrained to follow the rigid body motion:
      
          u(X) = θ × (X - X_ref) + t
      
      where `θ` is the rotation vector and `t` is the translation vector.
      
      Parameters
      ----------
      ref_point : NDArray[np.floating] of shape (3,)
          Reference point defining the center of rotation.
      
      slaves_inds : NDArray[np.integer] of shape (3, n_nodes)
          DOF indices of the slave nodes. Each column contains the
          x, y, z DOF indices of a slave node.
      
      slaves_positions : NDArray[np.floating] of shape (3, n_nodes)
          Physical coordinates of the slave nodes.
      
      Notes
      -----
      - Six reference DOFs (θx, θy, θz, tx, ty, tz) are added to represent
        the rigid body motion.
      - The constraint is expressed as a linear relation between the
        reference DOFs and the slave displacements.
      - This method is commonly used to impose rigid connections,
        master node formulations, or reference frame constraints.

  >>> add_eqs_from_inds_vals(
    self,
    inds: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    vals: Optional[numpy.ndarray[Any, numpy.dtype[numpy.floating]]] = None
)
      Impose pointwise Dirichlet conditions on selected DOFs.
      
      This is a convenience method that adds constraint equations of the form:
      
          u[inds] = vals
      
      
      Parameters
      ----------
      inds : NDArray[np.integer] of shape (n_eqs,)
          Indices of DOFs to constrain.
      
      vals : NDArray[np.floating] of shape (n_eqs,), optional
          Prescribed values associated with each constrained DOF.
          If None, zero values are imposed.
      
      Raises
      ------
      AssertionError
          If `vals` is provided and its size differs from `inds`.
      
      Notes
      -----
      This method is equivalent to adding rows of the identity matrix
      to the constraint operator.

  >>> make_C_k(
    self
) -> tuple[scipy.sparse._csc.csc_matrix, numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]]
      Construct the affine transformation (C, k) enforcing all Dirichlet constraints.
      
      This method solves the linear constraint system:
      
          D @ u = c
      
      by computing:
      
      - a matrix `C` forming a basis of the nullspace of `D`
      (i.e., D @ C = 0),
      - a particular solution `k` such that D @ k = c.
      
      Any admissible vector `u` satisfying the constraints can then be written as:
      
          u = C @ dof + k
      
      where `dof` is the reduced vector of unconstrained degrees of freedom.
      
      The nullspace basis and the particular solution are obtained through
      a sparse QR factorization of Dᵀ.
      
      Returns
      -------
      C : sps.csc_matrix
          Sparse matrix of shape (n_full_dofs, n_free_dofs) whose columns
          form a basis of the nullspace of `D`.
      
      k : NDArray[np.floating]
          Vector of shape (n_full_dofs,) representing a particular solution
          satisfying the constraints.
      
      Notes
      -----
      - The transformation (C, k) defines an affine parametrization of the
      admissible displacement space.
      - The reduced DOF vector `dof` corresponds to the coordinates of `u`
      in the nullspace basis.
      - The QR factorization is performed on Dᵀ to efficiently extract both
      the nullspace basis and the particular solution.

  >>> get_reduced_Ck(
    self
) -> tuple[scipy.sparse._matrix.spmatrix, numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]]
      Extract the affine constraint transformation restricted to physical DOFs.
      
      This method computes the full transformation (C, k) using `self.make_C_k()`
      and returns only the rows associated with the initial (physical) degrees
      of freedom. The resulting pair (C_u, k_u) defines:
      
          u_phys = C_u @ dof + k_u
      
      where `u_phys` satisfies all imposed Dirichlet constraints.
      
      Returns
      -------
      C_u : sps.spmatrix
          Reduced nullspace basis matrix of shape (nb_dofs_init, n_free_dofs).
      
      k_u : NDArray[np.floating]
          Reduced particular solution vector of shape (nb_dofs_init,).
      
      Notes
      -----
      - The full transformation (C, k) may include auxiliary reference DOFs
      introduced by multi-point or hierarchical constraints.
      - Only the rows corresponding to physical DOFs are returned.
      - A warning is emitted if reference DOFs remain unconstrained,
      which may indicate missing boundary specifications.

  >>> create_dirichlet(self)
      Build a `Dirichlet` object representing the reduced constraint transformation.
      
      This is a convenience wrapper around `get_reduced_Ck()` that constructs
      a `Dirichlet` object directly from the reduced affine mapping:
      
          u_phys = C_u @ dof + k_u
      
      Returns
      -------
      dirichlet : Dirichlet
          A `Dirichlet` instance encapsulating the reduced transformation matrices.

  >>> get_ref_multipliers_from_internal_residual(
    self,
    K_u_minus_f: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]
      Recover Lagrange multipliers associated with reference DOF constraints.
      
      This method reconstructs the Lagrange multipliers λ corresponding to
      reference DOFs using the internal residual vector of the mechanical system:
      
          r = K @ u - f
      
      The derivation relies on the partition of the transformation matrix:
      
          C = [C_u;
              C_ref]
      
      where `C_u` maps reduced DOFs to physical DOFs and `C_ref` maps them
      to reference DOFs.
      
      The multipliers satisfy:
      
          C_ref.T @ λ = - C_u.T @ r
      
      and are obtained via the least-squares solution:
      
          λ = - (C_ref @ C_ref.T)⁻¹ @ C_ref @ C_u.T @ r
      
      Parameters
      ----------
      K_u_minus_f : NDArray[np.floating]
          Internal residual vector of shape (nb_dofs_init,),
          corresponding to K @ u - f restricted to physical DOFs.
      
      Returns
      -------
      lamb : NDArray[np.floating]
          Vector of Lagrange multipliers associated with reference DOF constraints.
      
      Notes
      -----
      - The multipliers correspond to reaction forces or generalized constraint
      forces transmitted through reference DOFs.
      - The residual must be assembled consistently with the stiffness matrix
      and load vector used to compute the displacement field.
      - The matrix C_ref @ C_ref.T is assumed to be invertible, which holds
      when reference constraints are linearly independent.


GLOBAL FUNCTIONS:
~~~~~~~~~~~~~~~~~~
  >>> slave_reference_linear_relation_sort(
    slaves: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    references: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]]
) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]]
      Sorts the slave nodes based on reference indices to respect
      hierarchical dependencies (each slave is processed after its references).
      
      Parameters
      ----------
      slaves : NDArray[np.integer]
          Array of slave indices.
      references : NDArray[np.integer]
          2D array where each row contains the reference indices controlling a slave.
      
      Returns
      -------
      sorted_slaves : NDArray[np.integer]
          Array of slave indices sorted based on dependencies.

  >>> slave_reference_linear_relation_inner(
    indices: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    indptr: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    data: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    k: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    slaves: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    references: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]],
    coefs: numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]],
    sorted_slaves: numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]]
) -> tuple[numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]], numpy.ndarray[typing.Any, numpy.dtype[numpy.integer]], numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]], numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]]
      Applies slave-reference relations directly to CSR matrix arrays.
      
      Parameters
      ----------
      indices : NDArray[np.integer]
          Column indices of CSR matrix.
      indptr : NDArray[np.integer]
          Row pointers of CSR matrix.
      data : NDArray[np.floating]
          Nonzero values of CSR matrix.
      k : NDArray[np.floating]
          Vector to be updated.
      slaves : NDArray[np.integer]
          Array of slave indices.
      references : NDArray[np.integer]
          2D array where each row contains the reference indices controlling a slave.
      coefs : NDArray[np.floating]
          2D array of coefficients defining the linear relationship between references and
          slaves.
      sorted_slaves : NDArray[np.integer]
          Array of slave indices sorted in topological order.
      
      Returns
      -------
      rows : NDArray[np.integer]
          Updated row indices of COO matrix.
      cols : NDArray[np.integer]
          Updated column indices of COO matrix.
      data : NDArray[np.floating]
          Updated nonzero values of COO matrix.
      k : NDArray[np.floating]
          Updated vector.
