MODULE: IGA_for_bsplyne.Dirichlet
=================================
Documentation du module IGA_for_bsplyne.Dirichlet

CLASSE: Dirichlet
-----------------
A class to handle Dirichlet boundary conditions (BC) for a problem using an affine mapping.

The Dirichlet class provides methods to apply Dirichlet BCs by mapping degrees of freedom (dof)
to displacements (u) using the relation `u = C @ dof + k`. It supports creating instances with
identity mappings, locking specific displacement indices, and computing dof from displacements
via least squares approximation.

Attributes
----------
C : sps.csc_matrix
    The matrix used in the affine mapping from `dof` to `u`.
k : np.ndarray[np.floating]
    The vector used in the affine mapping from `dof` to `u`.

  >>> __init__(
    self,
    C: scipy.sparse._matrix.spmatrix,
    k: numpy.ndarray[numpy.floating]
)
      Initializes a Dirichlet instance with the given matrix and vector for affine mapping.
      
      Parameters
      ----------
      C : sps.spmatrix of float
          The matrix used to map degrees of freedom `dof` to displacements `u`.
      k : np.ndarray[np.floating]
          The vector used to map degrees of freedom `dof` to displacements `u`.

  >>> eye(cls, size: int)
      Create a `Dirichlet` instance with an identity mapping, where no degrees of freedom `dof` are locked.
      Sets `C` to the identity matrix and `k` to a zero-filled vector.
      
      Parameters
      ----------
      size : int
          Size of the `dof` and `u` vectors.
      
      Returns
      -------
      dirichlet : Dirichlet
          The identity `Dirichlet` instance.

  >>> lock_disp_inds(
    cls,
    inds: numpy.ndarray[numpy.integer],
    k: numpy.ndarray[numpy.floating]
)
      Creates a `Dirichlet` instance with specified displacement `u` indices locked to given values.
      
      Parameters
      ----------
      inds : np.ndarray[np.integer]
          Indices of the displacement field `u` to be locked.
      k : np.ndarray[np.floating]
          Values to lock the specified indices of `u` to.
          After this, `u[inds]` are set to `k[inds]` while other compontents are left free.
      
      Returns
      -------
      dirichlet : Dirichlet
          A `Dirichlet` instance with specified displacements locked.

  >>> set_u_inds_vals(
    self,
    inds: numpy.ndarray[numpy.integer],
    vals: numpy.ndarray[numpy.floating]
)
      Locks specified indices of the displacement field `u` to given values by modifying
      the matrix `C` and vector `k` accordingly. This involves zeroing out the specified
      rows in `C` and adjusting `k` to reflect the locked values.
      
      Parameters
      ----------
      inds : np.ndarray[np.integer]
          Indices of the displacement field `u` to be locked.
      vals : np.ndarray[np.floating]
          Values to lock the specified indices of `u` to.

  >>> slave_reference_linear_relation(
    self,
    slaves: numpy.ndarray[int],
    references: numpy.ndarray[int],
    coefs: Optional[numpy.ndarray[float]] = None
)
      This function modifies the sparse matrix `C` and the vector `k` to enforce
      reference-slave constraints in an optimization problem. The goal is to eliminate
      the degrees of freedom (DOFs) associated with slave nodes, keeping only the reference
      DOFs. The relation `u = C@dof + k` is updated so that slave DOFs are expressed as
      linear combinations of reference DOFs, reducing the problem's size while maintaining
      the imposed constraints.
      
      Parameters
      ----------
      slaves : np.ndarray[int]
          Array of slave indices.
      references : np.ndarray[int]
          2D array where each row contains the reference indices controlling a slave.
      coefs : Union[np.ndarray[float], None], optional
          2D array of coefficients defining the linear relationship between references and
          slaves.
          If None, the coefficients are set so that the slaves are the average of the references.
          By default None.

  >>> u_du_ddof(
    self,
    dof: numpy.ndarray[numpy.floating]
) -> tuple[numpy.ndarray[numpy.floating], scipy.sparse._csc.csc_matrix]
      Computes the displacement field `u` and its derivative with respect to the degrees of freedom `dof`.
      The displacement field is calculated as `u = C @ dof + k`, and its derivative is `C`.
      
      Parameters
      ----------
      dof : np.ndarray[np.floating]
          The degrees of freedom of the problem, representing the input to the affine mapping.
      
      Returns
      -------
      u, du_ddof : tuple[np.ndarray[np.floating], sps.csc_matrix]
          A tuple containing the displacement field `u` and its derivative with respect to `dof`.

  >>> u(
    self,
    dof: numpy.ndarray[numpy.floating]
) -> numpy.ndarray[numpy.floating]
      Computes the displacement field `u` using the affine mapping `u = C @ dof + k`.
      
      Parameters
      ----------
      dof : np.ndarray[np.floating]
          The degrees of freedom of the problem, representing the input to the affine mapping.
      
      Returns
      -------
      u : np.ndarray[np.floating]
          The computed displacement field `u`.

  >>> dof_lsq(self, u: numpy.ndarray[numpy.floating]) -> numpy.ndarray[numpy.floating]
      Computes the degrees of freedom `dof` from the displacement field `u` using a least squares approximation.
      This method performs a least squares 'inversion' of the affine mapping `u = C @ dof + k`.
      It solves the linear problem `C.T @ C @ dof = C.T @ (u - k)` for `dof`.
      
      Parameters
      ----------
      u : np.ndarray[np.floating]
          The displacement field from which to compute the degrees of freedom.
      
      Returns
      -------
      dof : np.ndarray[np.floating]
          The computed degrees of freedom corresponding to the given displacement field.


CLASSE: DirichletConstraintHandler
----------------------------------
Manage linear Dirichlet constraints for variational or optimization problems.

This class accumulates linear equations of the form `D @ u = c` representing Dirichlet
boundary conditions or linear relationships between degrees of freedom (DOFs), and
computes a reduced basis representation that parametrizes the set of admissible solutions.

Specifically, it computes matrices `C` and `k` such that any vector `u` satisfying
`D @ u = c` can be written as:

    u = C @ dof + k

where `dof` is a reduced vector of free parameters.

Attributes
----------
nb_dofs_init : int
    Number of DOFs in the original unconstrained system, before adding any reference DOFs.
lhs : sps.spmatrix
    Accumulated constraint matrix D (left-hand side of the Dirichlet conditions).
rhs : np.ndarray[np.floating]
    Accumulated right-hand side vector c of the Dirichlet conditions.

  >>> __init__(self, nb_dofs_init: int)
      Initialize a Dirichlet constraint handler.
      
      Parameters
      ----------
      nb_dofs_init : int
          The number of initial degrees of freedom in the unconstrained system.
          This value is used to size the initial constraint matrix and manage
          later extensions with reference DOFs.

  >>> copy(self) -> IGA_for_bsplyne.Dirichlet.DirichletConstraintHandler
      Create a deep copy of this DirichletConstraintHandler instance.
      
      Returns
      -------
      DirichletConstraintHandler
          A new instance with the same initial number of DOFs, constraint matrix, and right-hand side vector.
          All internal data is copied, so modifications to the returned handler do not affect the original.

  >>> add_eqs(
    self,
    lhs: scipy.sparse._matrix.spmatrix,
    rhs: numpy.ndarray[numpy.floating]
)
      Add linear constraint equations of the form D_new @ u = c_new.
      
      Appends the given equations to the existing Dirichlet constraint system.
      If the number of columns in `lhs` matches the initial DOF count, it is
      automatically extended with zero-padding to match the current DOF count
      (in case reference DOFs have been added).
      
      Parameters
      ----------
      lhs : sps.spmatrix
          Constraint matrix D_new of shape (n_eqs, nb_dofs) to be added to the system.
      rhs : np.ndarray[np.floating]
          Right-hand side values c_new of shape (n_eqs,) corresponding to the constraint.
      
      Raises
      ------
      ValueError
          If the number of columns in `lhs` does not match the initial or current DOF count.

  >>> add_ref_dofs(self, nb_dofs: int)
      Extend the system by adding new reference DOFs.
      
      This increases the number of columns in the constraint matrix by `nb_dofs`,
      initializing them with zeros in all existing constraint equations.
      
      Parameters
      ----------
      nb_dofs : int
          Number of new reference DOFs to append at the end of the current DOF vector.

  >>> add_ref_dofs_with_behavior(
    self,
    behavior_mat: scipy.sparse._matrix.spmatrix,
    slave_inds: numpy.ndarray[numpy.integer]
)
      Add new reference DOFs and define their influence on existing DOFs via a behavioral relation.
      
      This method appends new reference DOFs and enforces their relationship to existing
      DOFs (called "slaves") through a linear behavior matrix `behavior_mat`. The resulting constraints
      take the form:
      
          `behavior_mat @ ref_dofs - u[slave_inds] = 0`
      
      and are added to the global constraint system.
      
      Parameters
      ----------
      behavior_mat : sps.spmatrix
          Matrix of shape `(n_slaves, n_ref_dofs)` defining how each reference DOF influences
          the corresponding slave DOFs.
      
      slave_inds : np.ndarray[np.integer]
          Indices of the slave DOFs. Must have length `n_slaves` and must be in the same
          order as the rows of `behavior_mat`.
      
      Raises
      ------
      AssertionError
          If the number of rows in `behavior_mat` does not match the size of `slave_inds`.

  >>> add_rigid_body_constraint(
    self,
    ref_point: numpy.ndarray[numpy.floating],
    slaves_inds: numpy.ndarray[numpy.integer],
    slaves_positions: numpy.ndarray[numpy.floating]
)
      Add a reference node and impose a rigid body motion constraint on a set of slave nodes.
      
      This method introduces new reference degrees of freedom (DOFs) corresponding to a reference node
      located at `ref_point`, and constrains the displacements of a set of slave nodes (given by
      `nodes_inds` and `nodes_positions`) to follow a rigid body motion defined by the reference node.
      The rigid body motion includes both translation and rotation about the reference point.
      
      The imposed constraint ensures that the displacement of each slave node is a linear combination of
      the reference node's translation and rotation, enforcing a rigid connection between the reference
      and the slaves.
      
      Parameters
      ----------
      ref_point : np.ndarray[np.floating]
          Reference point (origin for rotation and translation), array of shape (3,) representing (x, y, z).
      slaves_inds : np.ndarray[np.integer]
          Indices of the degrees of freedom of the slave displacements.
          Shape (3, n), where n is the number of slave nodes; each column contains the x, y, z DOF indices for a node.
      slaves_positions : np.ndarray[np.floating]
          Initial positions of the slave nodes.
          Shape (3, n), where each column contains the (x, y, z) coordinates of a slave node in the physical space.

  >>> add_eqs_from_inds_vals(
    self,
    inds: numpy.ndarray[numpy.integer],
    vals: numpy.ndarray[numpy.floating] = None
)
      Add pointwise Dirichlet conditions by prescribing values at specific DOFs.
      
      This is a convenience method for adding equations of the form:
      
          u[i] = v
      
      for given indices `i` and corresponding values `v`.
      
      Parameters
      ----------
      inds : np.ndarray[np.integer]
          Indices of the DOFs to constrain.
      
      vals : np.ndarray[np.floating], optional
          Values to prescribe at the corresponding indices. If None, zeros are used.
          Must have the same size as `inds`.
      
      Raises
      ------
      AssertionError
          If `vals` is provided and does not match the shape of `inds`.

  >>> make_C_k(
    self
) -> tuple[scipy.sparse._matrix.spmatrix, numpy.ndarray[numpy.floating]]
      Construct the transformation (C, k) that enforces the Dirichlet constraints.
      
      Solves the linear constraint system D @ u = c by computing:
      - a basis `C` for the nullspace of D (i.e., D @ C = 0),
      - a particular solution `k` such that D @ k = c.
      
      Any admissible vector u satisfying the constraints can then be written as:
      
          u = C @ dof + k
      
      where `dof` is a reduced set of unconstrained degrees of freedom.
      
      Returns
      -------
      C : sps.spmatrix
          Basis of the nullspace of D, of shape (n_full_dofs, n_free_dofs), such that D @ C = 0.
      
      k : np.ndarray[np.floating]
          Particular solution of shape (n_full_dofs,) such that D @ k = c.

  >>> get_reduced_Ck(self) -> tuple[scipy.sparse._matrix.spmatrix, numpy.ndarray]
      Compute and return the reduced transformation matrices `(C_u, k_u)` for the physical degrees of freedom.
      
      This method extracts only the first `nb_dofs_init` rows of the full constraint transformation matrices `(C, k)`
      produced by `make_C_k()`, yielding a pair `(C_u, k_u)` such that the physical solution vector
      `u_phys = C_u @ dof_ext + k_u` satisfies all imposed Dirichlet constraints for the original system.
      
      Returns
      -------
      tuple[sps.spmatrix, np.ndarray]
          A tuple `(C_u, k_u)` where:
          - `C_u` (`sps.spmatrix`): The reduced nullspace basis matrix of shape (`nb_dofs_init`, n_free_dofs).
          - `k_u` (`np.ndarray`): The reduced particular solution vector of shape (`nb_dofs_init`,).
      
      Notes
      -----
      - Only the rows corresponding to the initial (physical) degrees of freedom are returned.
      - The full transformation matrices may include additional reference DOFs, which are omitted here.

  >>> create_dirichlet(self)

  >>> get_ref_multipliers_from_internal_residual(self, K_u_minus_f)
      Compute the Lagrange multipliers associated with reference point constraints
      from the internal residual vector of the mechanical problem.
      
      This method reconstructs the multipliers λ enforcing the constraints linked to
      reference degrees of freedom (DOFs) using the internal residual
      `K_u_minus_f = K @ u - f`. The derivation relies on the relation:
      
          C_ref.T @ λ = - C_u.T @ (K @ u - f),
      
      where the transformation matrix C = [C_u; C_ref] maps reduced DOFs to the full set
      (physical + reference) while satisfying all constraint equations
      (built via a QR decomposition in `make_C_k`).
      
      Solving for λ in a least-squares sense yields:
      
          λ = - (C_ref @ C_ref.T)^{-1} @ C_ref @ C_u.T @ (K @ u - f).
      
      Parameters
      ----------
      K_u_minus_f : np.ndarray
          The internal residual vector (K @ u - f) of size `(nb_dofs_init,)`,
          expressed only for the physical DOFs.
      
      Returns
      -------
      np.ndarray
          The Lagrange multipliers λ associated with the reference point constraints.
      
      Notes
      -----
      - The result corresponds to the reaction forces (or generalized forces) transmitted
      by the reference DOFs onto the system, ensuring equilibrium.
      - The internal residual `K @ u - f` must be assembled consistently
      with the stiffness matrix `K` and the load vector `f`.
      - This method assumes that `C_ref @ C_ref.T` is invertible,
      which is guaranteed if the reference constraints are linearly independent.


FONCTIONS GLOBALES:
~~~~~~~~~~~~~~~~~~
  >>> slave_reference_linear_relation_sort(
    slaves: numpy.ndarray[int],
    references: numpy.ndarray[int]
) -> numpy.ndarray[int]
      Sorts the slave nodes based on reference indices to respect
      hierarchical dependencies (each slave is processed after its references).
      
      Parameters
      ----------
      slaves : np.ndarray[int]
          Array of slave indices.
      references : np.ndarray[int]
          2D array where each row contains the reference indices controlling a slave.
      
      Returns
      -------
      sorted_slaves : np.ndarray[int]
          Array of slave indices sorted based on dependencies.

  >>> slave_reference_linear_relation_inner(
    indices: numpy.ndarray[int],
    indptr: numpy.ndarray[int],
    data: numpy.ndarray[float],
    k: numpy.ndarray[float],
    slaves: numpy.ndarray[int],
    references: numpy.ndarray[int],
    coefs: numpy.ndarray[float],
    sorted_slaves: numpy.ndarray[int]
) -> tuple[numpy.ndarray[int], numpy.ndarray[int], numpy.ndarray[float], numpy.ndarray[float]]
      Applies slave-reference relations directly to CSR matrix arrays.
      
      Parameters
      ----------
      indices : np.ndarray[int]
          Column indices of CSR matrix.
      indptr : np.ndarray[int]
          Row pointers of CSR matrix.
      data : np.ndarray[float]
          Nonzero values of CSR matrix.
      k : np.ndarray[float]
          Vector to be updated.
      slaves : np.ndarray[int]
          Array of slave indices.
      references : np.ndarray[int]
          2D array where each row contains the reference indices controlling a slave.
      coefs : np.ndarray[float]
          2D array of coefficients defining the linear relationship between references and
          slaves.
      sorted_slaves : np.ndarray[int]
          Array of slave indices sorted in topological order.
      
      Returns
      -------
      rows : np.ndarray[int]
          Updated row indices of COO matrix.
      cols : np.ndarray[int]
          Updated column indices of COO matrix.
      data : np.ndarray[float]
          Updated nonzero values of COO matrix.
      k : np.ndarray[float]
          Updated vector.
